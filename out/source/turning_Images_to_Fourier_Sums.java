/* autogenerated by Processing revision 1293 on 2023-12-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import gab.opencv.*;
import peasy.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class turning_Images_to_Fourier_Sums extends PApplet {




PeasyCam cam;
PImage src, dst;
OpenCV opencv;
int j = 0;
ArrayList<Contour> contours;
ArrayList<PVector> loc ;
float time = 0;

ArrayList<PVector> path = new ArrayList<PVector>();
FloatList x = new FloatList();
FloatList y = new FloatList();
ArrayList<Circle> fourierY;
ArrayList<Circle> fourierX;

String imgName = "\\images\\cat2.png";

public void setup() {
  /* size commented out by preprocessor */;
  cam = new PeasyCam(this, 1000);
  background(0);
  loc = getPoints(imgName);
  println(loc.size());
  colorMode(HSB);

  for (int i = 0; i < loc.size(); i = i + 3) {
    x.append(loc.get(i).x);
    y.append(loc.get(i).y);

     //x.append(map(loc.get(i).x,0,100,0,500));
     //y.append(map(loc.get(i).y,0,100,0,500));
  }

  fourierX = bubbleSort(dft(x));
  fourierY = bubbleSort(dft(y));
  
  println("No. of Circles: ",fourierX.size());
}

public void draw() {
    background(0, 0);
    
    PVector v_x = epiCycle(width/2 + 100, 200, 0, fourierX);
    PVector v_y = epiCycle(100, height/2 + 100, HALF_PI, fourierY);
    PVector vec = new PVector(v_x.x, v_y.y);

    line(v_x.x, v_x.y, vec.x, vec.y);
    line(v_y.x, v_y.y, vec.x, vec.y);

    path.add(vec);
    noFill();
    
    beginShape();
    stroke(90,255,255);
    strokeWeight(3);
    for (int i = 0; i < path.size(); i++) {
        if (i != 0) {
          if (abs((path.get(i).mag()-path.get(i-1).mag()))<20) {
            stroke(90,255,255);
            line(path.get(i).x, path.get(i).y,path.get(i-1).x, path.get(i-1).y);
          }
          
          // if (abs((path.get(i).mag()-path.get(i-1).mag()))>50) {
          //   beginShape();
          //   stroke(255,0,0);
          //   vertex(path.get(i-1).x, path.get(i-1).y);
          //   vertex(path.get(i).x, path.get(i).y);
          //   endShape();
          // } else {
          //   beginShape();
          //   stroke(90,255,255);
          //   vertex(path.get(i-1).x, path.get(i-1).y);
          //   vertex(path.get(i).x, path.get(i).y);
          //   endShape();
          // }
          // if(i<100){
             //println(abs((path.get(i).mag()-path.get(i-1).mag())));
          // }
        }
         //vertex(path.get(i).x, path.get(i).y);
        
    }
    endShape();
    strokeWeight(1);
    float dt = TWO_PI / fourierY.size();
    time += dt;

    if (time > TWO_PI) {
        time = 0;
        path = new ArrayList<PVector>();
        noLoop();
    }
    //delay(1000);
}
class Circle{
    float freq, amp, phase, re, im;

    Circle(float amp_val, float freq_val, float phase_val, float real, float imag){
        amp = amp_val;
        freq = freq_val;
        phase = phase_val;
        re = real;
        im = imag;
    }
    Circle(float amp_val, float freq_val, float phase_val){
        amp = amp_val;
        freq = freq_val;
        phase = phase_val;
    }

    public float getRe(){
        return re;
    }
    public float getIm(){
        return im;
    }

    public float getAmp(){
        return amp;
    }

    public float getFreq(){
        return freq;
    }

    public float getPhase(){
        return phase;
    }

    public void printParam(){
        println("amp: ",amp," frequency: ",freq," phase: ",phase, " Real: ", re, " Imag: ",im);
    }
}
public ArrayList<Circle> dft(FloatList x){
    int N = x.size();
    ArrayList<Circle> X = new ArrayList<Circle>();

    for (int k = 0; k < N; ++k) {
        float re = 0;
        float im = 0;

        for (int n = 0; n < N; ++n) {
            float phi = (TWO_PI * k * n) / N;
            re += x.get(n) * cos(phi);
            im += x.get(n) * sin(phi);
        }
        re = re / N;
        im = im / N;

        float amp = sqrt(re*re + im*im);
        float phase = atan2(im,re);

        Circle circ = new Circle(amp, k, phase, re, im);
        X.add(circ);
    }
    return X;
}


public PVector epiCycle(float x, float y, float rotation, ArrayList<Circle> fourier){

    for (int i = 0; i < fourier.size(); ++i) {
        float prevx = x;
        float prevy = y;
        
        Circle circ = fourier.get(i); 
        float freq = circ.getFreq();
        float phase = circ.getPhase();
        float radius = circ.getAmp();

        x += radius * cos(freq * time + phase + rotation);
        y += radius * sin(freq * time + phase + rotation);
        
        stroke(255, 100);
        noFill();
        circle(prevx, prevy, radius * 2);
        
        stroke(255);
        line(prevx, prevy, x, y);
        
        fill(255);
        circle(x,y,0.5f);
    }
    return (new PVector(x,y));
}
public ArrayList<PVector> getPoints(String imageName){
    src = loadImage(imageName); 
    opencv = new OpenCV(this, src);

    opencv.gray();
    opencv.threshold(100);
    dst = opencv.getOutput();

    contours = opencv.findContours();
    println("found " + contours.size() + " contours");
    
    ArrayList<PVector> loc = new ArrayList<PVector>();
    for (Contour contour : contours) {
        for (PVector point : contour.getPoints()) {
            loc.add(point);
        }
  }
    return loc;
}
// Implement a bubble sort algorithm that works on an ArrayList of objects
public ArrayList<Circle> bubbleSort(ArrayList<Circle> list) {
  // Get the size of the list
  int n = list.size();
  // Loop through the list
  for (int i = 0; i < n - 1; i++) {
    // Loop through the list again, starting from the end
    for (int j = n - 1; j > i; j--) {
      // Get the current and previous Circle objects
      Circle current = list.get(j);
      Circle previous = list.get(j - 1);
      // Compare their amp attributes
      if (abs(current.getAmp()) > abs(previous.getAmp())) {
        // Swap them in the list
        list.set(j, previous);
        list.set(j - 1, current);
      }
    }
  }
  return list;
}


  public void settings() { size(1200, 600, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "turning_Images_to_Fourier_Sums" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
